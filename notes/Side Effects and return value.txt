## ğŸ§¨ What the heck is a *side effect* in Python?

In programming, a **side effect** is anything a function does that **affects the outside world or program state**, **besides just returning a value**.

Think of it like this:

> If a function returns something AND ALSO changes something outside itself...
> ğŸ«£ Thatâ€™s a **side effect**.

---

## âš ï¸ Common Side Effects:

* Printing to the screen (`print("hi")`)
* Writing to a file
* Modifying a global variable
* Changing a list or dict that was passed in
* Sending data over the internet
* Updating a database
* Raising an exception

---

### ğŸ¤¯ Example 1 â€” With Side Effect:

```python
my_list = [1, 2, 3]

def add_item(lst):
    lst.append(4)   # modifies the original list = side effect

add_item(my_list)
print(my_list)  # [1, 2, 3, 4] â† function changed the outside world
```

Even though the function didnâ€™t *return* anything, it still **altered** `my_list`. Thatâ€™s a side effect!

---

### ğŸ’… Example 2 â€” No Side Effect:

```python
def add(a, b):
    return a + b  # no side effects, just gives a new value

result = add(3, 4)
print(result)  # 7
```

No external changes. It just does math and returns it = pure, clean, innocent little function ğŸ˜‡

---

### ğŸ‘» Side Effects Can Be Dangerous!

Because theyâ€™re **hidden**, they can make your code harder to understand and debug.

Imagine a function that updates a database *without telling you* ğŸ¥´
Now you're wondering:

> â€œWhy is my data all messed up!?â€

---

## ğŸ¤“ Why it matters?

In clean, functional-style programming:

* **Pure functions** = no side effects
* **Better testing, fewer bugs, more predictable**

BUT side effects are sometimes **necessary** â€” I mean, how would you show anything on the screen without `print()`? ğŸ¤·â€â™‚ï¸

---

### ğŸ” Think of it like this:

| Function Type    | What it does                                | Example                                   |
| ---------------- | ------------------------------------------- | ----------------------------------------- |
| Pure             | Takes input, returns output. No side stuff. | `def add(a, b): return a + b`             |
| With Side Effect | Also touches outside world                  | `print()`, modifying a list, saving files |

---

## ğŸ’¡ TL;DR:

> **A side effect is when a function messes with something outside its own local world.**
> Itâ€™s like farting in a room and pretending you didnâ€™t â€” everyone *knows* something changed ğŸ˜¤ğŸ’¨

---


---

## ğŸ§  WHAT IS A RETURN VALUE?

A **return value** is the **thing a function gives you back** when itâ€™s done doing its job.

You call a function â†’ it runs â†’ it says:

> â€œHere bro, take this!â€ and hands you back a value.

That value is called the **return value**.

---

## âš™ï¸ In Python, it looks like this:

```python
def add(a, b):
    return a + b
```

Now when you *call* that function:

```python
result = add(5, 3)
print(result)  # ğŸ”¥ prints 8
```

ğŸ’¥ `add(5, 3)` returned `8`, and we stored it in `result`.

---

## ğŸ¥± So if I donâ€™t use `return`?

Your function gives back... **nothing**. Technically, it returns `None`.

```python
def say_hi():
    print("Hi!")

x = say_hi()
print(x)  # ğŸ‘‰ This will print "Hi!" and then "None"
```

Why? Because `say_hi()` didnâ€™t *return* anything â€” just printed stuff = no return value = Python gives you `None` by default.

---

## ğŸ§ª You can use return values like this:

```python
def square(x):
    return x * x

num = 4
squared = square(num)
print(squared)  # 16
```

The function **did math**, gave back the result, and let us **store** it, **use** it, **print** it, whatever.

---

## ğŸ”„ `return` literally *exits* the function

```python
def wow():
    print("I'm before return")
    return "âœ¨MAGICâœ¨"
    print("I'm after return")  # ğŸ˜¶ This will NEVER run!
```

Once Python hits `return`, itâ€™s like:

> "Peace out! I'm done here. Not doing anything else!" ğŸƒğŸ’¨

---

## ğŸ“¦ You can even return **multiple values** (Python's cool like that):

```python
def divide(a, b):
    return a // b, a % b  # integer division and remainder

q, r = divide(10, 3)
print(q, r)  # 3 1
```

It returns a **tuple** (group of values), and you can unpack it easily.

---

### ğŸ”¥ TL;DR - Return value = your functionâ€™s output gift ğŸ

| What You Do        | What Happens                            |
| ------------------ | --------------------------------------- |
| Use `return`       | Function gives back a value             |
| Donâ€™t use `return` | Python returns `None` by default        |
| Store it in a var  | You can reuse the function's output     |
| Donâ€™t store it     | The return value is lost in the void ğŸŒŒ |

---

Want a dumb/fun analogy? ğŸ˜
Calling a function is like ordering pizza ğŸ•

* **Input** = what toppings you want
* **Function** = the kitchen making it
* **Return value** = the pizza they give back
* If the kitchen says nothing and you hear silenceâ€¦ guess what, **youâ€™re eating `None`** ğŸ˜‚
